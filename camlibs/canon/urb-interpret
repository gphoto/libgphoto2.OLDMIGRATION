#!/usr/bin/perl
#
# $Id$
#
# This script is only of interest for developers who want to analyze
# USB snoopy dumps of canon camera communication made with USB snoopy 0.13
# (http://www.jps.net/~koma/). There are two slightly different formats
# recognized.
#
# NOTE: All "interesting" URB's generate a line ending with "***", so the
#  command "urb-interpret foo.LOG | grep '\*\*\*$'" will generate a summary
#  of the log.
#

use strict;
use warnings;

my %canon_cmd = (
		 "0x01 0x11 0x202" => "Get picture/thumbnail",
		 "0x01 0x12 0x201" => "Identify camera request",
		 "0x03 0x12 0x201" => "Get time",
		 "0x04 0x12 0x201" => "Set time",
		 "0x05 0x11 0x201" => "Make directory",
		 "0x05 0x12 0x201" => "Change owner",
		 "0x06 0x11 0x201" => "Remove directory",
		 "0x09 0x11 0x201" => "Disk info request",
		 "0x0a 0x11 0x202" => "Flash device identification",
		 "0x0a 0x12 0x201" => "Power supply status",
		 "0x0b 0x11 0x202" => "Get directory",
		 "0x0d 0x11 0x201" => "Delete file",
		 "0x0e 0x11 0x201" => "Set file attribute",
		 "0x13 0x12 0x201" => "Remote Camera control",
		 "0x17 0x12 0x202" => "Download a captured image",
		 "0x18 0x12 0x202" => "Download a captured preview",
		 #"0x1a 0x12 0x201" => "Mystery command",
		 "0x1b 0x12 0x201" => "EOS lock keys",
		 "0x1c 0x12 0x201" => "EOS unlock keys",
		 "0x1d 0x12 0x201" => "EOS get body ID",
		 "0x1f 0x12 0x201" => "Get camera photo abilities?",
		 "0x20 0x12 0x201" => "Lock keys, turn off LCD"	
		);

my %control_subcmd = ( "0x00" => "Camera control init",
		       "0x01" => "Exit release control",
		       "0x02" => "Start viewfinder",
		       "0x03" => "Stop viewfinder",
		       "0x04" => "Release shutter",
		       "0x07" => "Set release params",
		       "0x09" => "Set transfer mode",
		       "0x0a" => "Get release params",
		       "0x0b" => "Get zoom position",
		       "0x0c" => "Set zoom position",
		       "0x0d" => "Get available shot",
		       "0x0e" => "Set custom func.",
		       "0x0f" => "Get custom func.",
		       "0x10" => "Get extended release params size",
		       "0x11" => "Get extended params version",
		       "0x12" => "Get extended release params",
		       "0x13" => "Set extended params",
		       "0x14" => "Select camera output",
		       "0x15" => "Do AE, AF, and AWB"
		       );

my ($file, %urb, %urbdata, %urbpipe);

if ($#ARGV == -1) {
	warn("Syntax: $0 file [file ...]\n");
	exit(1);
}

foreach $file (@ARGV) {
	open(FILE, "< $file") or die("Could not open file '$file' for reading: $!\n");

	my $line;
	my $byte_offset;
	my $dumping_urbdata = 0;
	my $current_urb = -1;
	my $buffer = 0;
	my $direction;
	my $current_lines;

	warn("FILE: $file\n");

	while ($line = <FILE>) {
		chomp($line);
		$line =~ s/\r//;	# Trim possible <CR> (from Windows)
		
		if ($line =~ />>> URB (\d+) going down/) {
			$current_urb = $1;
			$direction = "down";
			#warn("URB $current_urb down...\n");
		} elsif ($line =~ /<<< URB (\d+) coming back/) {
			$current_urb = $1;
			#warn("URB $current_urb read\n");
			$direction = "back";
		} elsif ( $line =~ /Diag Driver: Receive/
			  || $line =~ /isEchoRequest/
			  || $line =~ /isWakeUpRequest/
			  || $line =~ /filter/ ) {
			 next;
		} else {
			if ($current_urb) {
				if ( $line =~ /^(\d+)\s+(\d\d:\d\d:\d\d [AP]M)\s+0000:\s+/
				     || $line =~ /^(\d+)\s+(\d+\.\d+)\s+0000:\s+/ ) {
					#warn ( "dumping URB data\n" );
					$dumping_urbdata = 1;
					$current_lines = 0;
					$byte_offset = "0000";
				
					# start of urbdata, decide which buffer this is
					if ($urbdata{$current_urb}{buffer0}) {
						$buffer = "buffer1";
					} else {
						$buffer = "buffer0";
					}
				
					#warn("URB $current_urb $buffer\n");
					
					# mark that the buffer goes here
					push(@{$urb{$current_urb}}, "[buffer $buffer]");
				}
				if ($dumping_urbdata) {
					# Within data buffer
					my $hex = "";
					#if ($line =~ /^(\d+)	([\w\d:\.]+?)	\s*([\da-f]+):( ([\da-f][\da-f])+) 	/) {
					if ($line =~ /^(\d+)\s+(\d\d:\d\d:\d\d [AP]M)\s+([\da-f]+):((\s[\da-f][\da-f])+)\s+$/
					    || $line =~ /^(\d+)\s+(\d+\.\d+)\s+([\da-f]+):((\s[\da-f][\da-f])+)\s+$/) {
						$byte_offset = $3;
						$hex = $4;
					} else {
						if ($line =~ /^(\d+)\s+(\d\d:\d\d:\d\d [AP]M)\s+([\da-f]+):\s+$/
						    || $line =~ /^(\d+)\s+(\d+\.\d+)\s+([\da-f]+):\s+$/ ) {
							# every other line is this kind of line, data offset
							$byte_offset = $3;
							next;				
						} elsif ($line =~ /^(\d+)\s+([\w\d:\.]+?)	(( [a-f0-9][a-f0-9])+)	/) {
							$hex = $3;
						} else {
							if ($line =~ /(URB_FUNCTION|UrbLink)/) {
								# this is not a urbdata line. reset.
								$dumping_urbdata = 0;
								next;	# unimportant line, just go to next
							} else {
								#warn("$file:$. Unknown data '$line' when dumping URB data\n");
								next;
							}
						}
					}
					if ($hex) {
						if ( $urbdata{$current_urb}{op} eq "WRITE" ) {
							# If this is an OUT transaction, try to decode
							#  Canon command codes. These will be in two lines
							#  of the buffer dump: the first, starting at offset
							#  0000:; and the fifth, starting at offset 0040:
							if (hex($byte_offset) == 0x00) {
								my @h = split(" ", $hex);
								if ( $#h < 8 ) {
									warn ( "URB $current_urb has digits missing from cmd3: probable truncated packet\n" );
									$urbdata{$current_urb}{cmd3} = "BAD";
								}
								else {
									$urbdata{$current_urb}{cmd3} = sprintf("0x%02x", hex("$h[7]$h[6]$h[5]$h[4]"));
								}
							} elsif (hex($byte_offset) == 0x40) {
								my @h = split(" ", $hex);
								if ( defined($h[4]) ) {
									$urbdata{$current_urb}{cmd1} = "0x$h[4]";
								}
								if ( defined($h[7]) ) {
									$urbdata{$current_urb}{cmd2} = "0x$h[7]";
								}
							} elsif (hex($byte_offset) == 0x50) {
								if ( defined ( $urbdata{$current_urb}{cmd1} )
								     &&  defined ( $urbdata{$current_urb}{cmd2} ) ) {
									if ( $urbdata{$current_urb}{cmd1} eq "0x13"
									     || $urbdata{$current_urb}{cmd2} eq "0x12" ) {
										my @h = split(" ", $hex);
										$urbdata{$current_urb}{subcmd} = "0x$h[0]";
									}
								}
							}
						}

						if ( $current_lines < 65 ) {
							push(@{ $urbdata{$current_urb}{ $buffer } }, hex_format($byte_offset, $hex));
						}
						$current_lines++;
						$byte_offset = -1;
						next;
					}
				} else {
					# Not within data buffer; parse other info
					if ($line =~ /\sInterface\[0\]: Pipes\[(\d+)\] : PipeHandle\s+= 0x([\da-f]+)	/) {
						# remember URB pipe
						$urbpipe{$2} = $1;
						warn("PIPE $2 = $1\n");
						print ( "Pipe $2 = $1" );
						if ( $1 == 0 ) {
						    print ( " (main)\n" );
						} elsif ( $1 == 2 ) {
						    print ( " (interrupt)\n" );
						} else {
						    print ( "\n" );
						}
					} elsif ($line =~ /\sPipeHandle\s+= ([\da-f]+)/) {
						# check if we know this URB pipe
						if ( defined ( $urbpipe{$1} ) ) {
							$urbdata{$current_urb}{pipe} = $urbpipe{$1};
						} else {
							$urbdata{$current_urb}{pipe} = "UNKNOWN";
						}
						#warn("URB $current_urb PIPE $1 = $urbdata{$current_urb}{pipe}\n");
					}
					
					if ($line =~ /\sTransferFlags.+USBD_TRANSFER_DIRECTION_(OUT|IN)/) {
						# OP in "coming back" is most reliable, and that one
						# is always after "going down" so we don't neeed to
						# check previous value here, just overwrite
						if ($1 eq "OUT") {
							$urbdata{$current_urb}{op} = "WRITE";
						} elsif ($1 eq "IN") {
							$urbdata{$current_urb}{op} = "READ";
						} else {
							warn ( "Invalid transfer direction \"$1\"\n" );
						}
					} elsif ( $line =~ /URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE/ ) {
						# This is a read request, but lacks the "TransferFlags"
						#  keyword.
						$urbdata{$current_urb}{op} = "READ";
					}
					if ($line =~ /\sTransferBufferLength = ([\da-f]+)/) {
						my $t = hex($1);

						if ( !defined($urbdata{$current_urb}{op}) ) {
							warn ( "URB $current_urb length=$t, but don't know type\n" );
						}
						elsif ($urbdata{$current_urb}{op} eq "READ") {
							# ok, this is read operation. info is
							# always good.
							$urbdata{$current_urb}{bytes} = $t;
						} elsif ($urbdata{$current_urb}{op} eq "WRITE") {
							if ($direction eq "down") {
								$urbdata{$current_urb}{bytes} = $t;
							}
							# else, this information is unreliable
						}
					}
				}
			}
		}
		
		if ($line =~ /^(\d+)	([\w\d:\.]+?)	(.+?)\s*$/) {
			# we want to trim down the line numbers and time
			
			my $lineno = $1;
			my $time = $2;
			my $rest = $3;
			
			$line = sprintf("%.5d %.3f  %s", $lineno, $time, $rest);
		} else {
			# replace tabs with two spaces to make lines shorter
			$line =~ s/	/  /g;
		}

		if ($current_urb == -1) {
			print("$line\n");
		} else {
			push(@{$urb{$current_urb}}, $line);
		}
	}
	
	close(FILE);

	warn("\noutputting formatted data\n");
	
	my $n_skipped = 0;

	foreach $current_urb (sort numerically keys %urb) {

		# these are declared for readability
		my $cmd1 = $urbdata{$current_urb}{cmd1};
		my $cmd2 = $urbdata{$current_urb}{cmd2};
		my $cmd3 = $urbdata{$current_urb}{cmd3};
		my $pipe = $urbdata{$current_urb}{pipe};
		my $type = $urbdata{$current_urb}{type};
		my $op = $urbdata{$current_urb}{op};
		my $length = $urbdata{$current_urb}{bytes};
		my $keep_alive = 0;

		if ( defined($op) ) {
			if ( defined($pipe) ) {
				if ( $pipe eq "2" && $length eq "0") {
					$keep_alive = 1;
				}
			}
			if ( !defined($length) ) {
				warn ( "Missing operation length in URB $current_urb\n" );
			}
			if ( $keep_alive ) {
				$n_skipped++;
				next;
			} else {
				if ( $n_skipped ) {
					print ( "\n*** Skipped $n_skipped null interrupt reads ***\n" );
					$n_skipped = 0;
				}
				if ($op eq "READ") {
					if ( defined($length) ) {
						if ( $pipe eq "2" ) {
						    printf ( "\n*** URB $current_urb interrupt read 0x%02x bytes ***\n\n", $length );
						} elsif ($length == 0x40) {
							print("\n\n\n\n*** URB $current_urb possible CANON RESPONSE ***\n");
						} elsif ($length == 0x01) {
							print("\n\n\n\n*** URB $current_urb PROBABLY CAMERA INIT ***\n\n");
						} else {
							print("\n");
						}
					} else {
						print("\n");
					}
				} elsif ($op eq "WRITE") {
					my $cmd;
					if ( defined($urbdata{$current_urb}{cmd1}) ) {
						$cmd = "$urbdata{$current_urb}{cmd1}";
					} else {
						$cmd = "LOST";
					}
					if ( defined($urbdata{$current_urb}{cmd2}) ) {
						$cmd = "$cmd $urbdata{$current_urb}{cmd2}";
					} else {
						$cmd = "$cmd LOST";
					}
					if ( defined($urbdata{$current_urb}{cmd3}) ) {
						$cmd = "$cmd $urbdata{$current_urb}{cmd3}";
					} else {
						$cmd = "$cmd LOST";
					}
					if ( defined ( $length ) ) {
						if ($length >= 0x50) {
							if ( $cmd eq "LOST LOST LOST" ) {
								warn ( "Command string is $cmd at URB $current_urb\n" );
							}
							elsif ($canon_cmd{$cmd}) {
								printf("\n\n\n\n*** URB $current_urb CANON COMMAND '$canon_cmd{$cmd}' ($cmd) 0x%02x bytes", $length);
								if ( $cmd eq "0x13 0x12 0x201" ) {
									if ( $control_subcmd{$urbdata{$current_urb}{subcmd}} ) {
										print ( ": $control_subcmd{$urbdata{$current_urb}{subcmd}} ***\n\n" );
									} else {
										print ( ". Unknown subcommand: $urbdata{$current_urb}{subcmd} ***\n\n" );
									}
								} else {
									print ( " ***\n\n" );
								}
							} elsif ($cmd3 eq "0x201" or $cmd3 eq "0x202") {
								printf("\n\n\n\n*** URB $current_urb PROBABLE CANON COMMAND ($cmd) 0x%02x bytes ***\n\n", $length);
							} else {
								printf("\n\n\n\n*** URB $current_urb possible CANON COMMAND ($cmd) 0x%02x bytes ***\n\n", $length);
							}
						} elsif ($cmd3 eq "0x201" or $cmd3 eq "0x202") {
							if ($canon_cmd{$cmd}) {
								printf("\n\n\n\n*** URB $current_urb CANON COMMAND '$canon_cmd{$cmd}' ($cmd) 0x%02x bytes ***\n\n", $length);
							} else {
								printf("\n\n\n\n*** URB $current_urb PROBABLE CANON COMMAND ($cmd) 0x%02x bytes ***\n\n", $length);
							}
						}
					}
				}
			}

			if ( defined($length) ) {
				printf("%s 0x%x BYTES\n", $op, $length);
			} else {
				printf( "%s *unknown* BYTES\n", $op );
			}
		}
		
		if ($urbdata{$current_urb}{pipe}) {
			print("*** URB $current_urb  PIPE $urbdata{$current_urb}{pipe}\n");
		} else {
			print("*** URB $current_urb\n");
		}
		foreach $line (@{$urb{$current_urb}}) {
			if ($line =~ /^\[buffer (buffer\d)\]$/) {
				my $b = $1;
				
				if ($b eq "buffer0" and $urbdata{$current_urb}{buffer1}) {
					# this is buffer 0 but this URB has two buffers,
					# this one is FOO (buffer contents before read typically)
					# so we just skip it
					print("[cut]\n");
					next;
				}
				
				print("DATA:\n",
				     join("\n", @{ $urbdata{$current_urb}{$b} }), 
				     "\n");
			} else {
				print("$line\n");
			}
		}
	}
}

warn("\nDone\n\n");
exit(0);


# SUBROUTINES
# -----------

sub numerically { $a <=> $b };

sub hex_format
{
	my $byte_offset = shift;
	my $hex = shift;
	
	$hex =~ s/^\s*(.+?)\s*$/$1/;	# trim
	my @chars = split(" ", $hex);
	my $out_rad = "$byte_offset  $hex  ";
	
	# if not a full line, add whitespace			
	if ($#chars < 15) {
		$out_rad .= " " x ((15 - $#chars) * 3);
	}

	# add ASCII
	my $ch;
	foreach $ch (@chars) {
		my $i = hex($ch);
		if ($i >= 32 and $i < 127) {
			$out_rad .= sprintf("%c", $i);
		} else {
			$out_rad .= ".";
		}
	}

	return $out_rad;
}
